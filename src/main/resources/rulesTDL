	1. Поддерживаемые конструкции -- см. также ANTLR-грамматика
	import file -- импортирование всего, что есть в файле (для наших целей эквивалентно добавлению всего указанного файла в данный файл)
	type -- определение типа как совокупности полей, вместе с типом определяется единственный конструктор (с тем же названием, что и у типа,
и с параметрами, соответствующими полям типа).
	function -- определение функции, её параметров и (опционально) тела
	invoke on -- переопределение оператора вызова () на определённом типе (без параметров), может использовать поля заданного типа, а также
this как специальную переменную заданного типа
	as -- явное преобразование типа к заданному (в случае неудачи программа завершает работу)
	if -- проверка условия (else можно не поддерживать)
	return -- возврат из функции
	=+-*/<> -- операции
	. -- обращение к полю
	2. Общие принципы функционирования программы:
	все переменные получают значение один раз
	объявлением переменной служит единственное присваивание в неё
	переменные бывают локальные (объявленные в функциях) и глобальные (объявленные вне функций)
	стандартные типы: String и Integer , строковые литералы пишем в двойных кавычках
	типы переменных и результатов функций в языке не указываются
	для применения . и вызова через invoke on необходимо, чтобы у типа получателя / переменной было соответствующее поле / invoke on. Знает
тип переменной компилятор только в двух случаях: после вызова конструктора и после применения as
	прочие функции могут вызываться с параметрами любого типа, компилятор их не проверяет, при наличии двух и более функций с одинаковым
именем и одинаковым числом параметров возникает ошибка ambiguity
	при наличии двух и более типов с одинаковыми именами также возникает ambiguity, даже в случае, если количество полей у этих типов
отличается
	при наличии в доступе одноимённых функции с некоторым количеством параметров и типа с тем же количеством полей функция считается более
приоритетной
	при наличии в доступе одноимённой переменной, на которой возможен invoke on, и функции без параметров, функция считается более
приоритетной
	у любого типа, определённого через type, должно быть хотя бы одно поле, в противном случае на нём возникает ошибка empty type
	при попытке вызвать несуществующую функцию, обратиться к несуществующему полю, импортировать несуществующий файл, выполнить
преобразование к несуществующему типу возникает ошибка unresolved
	при попытке вызвать существующую функцию или конструктор с неправильным количеством аргументов возникает ошибка unmatching arguments
	Что ТРЕБУЕТСЯ сделать (достаточна реализация соответствующих API без консольного / графического режима):
	построить синтаксическое дерево программы в удобной для дальнейшего анализа форме (в проекте грамматики имеется пример ANTLR-парсера,
решающего эту часть задачи; вы можете использовать этот парсер или написать свой)
	провести в программе разрешение имён, поставив в соответствие каждому использованию имени его определение, сообщить обо всех найденных
ошибках unresolved, ambiguity, unmatching arguments, empty type
	сообщить обо всех объектах программы, которые были объявлены, но ни разу не использовались в ней (unused). К этому относятся: типы, для
которых не было ни вызовов конструктора, ни преобразований к ним; поля типов, к которым ни разу не обращались; invoke on , которые ни разу
не были вызваны; функции, которые ни разу не были вызваны; переменные (глобальные и локальные), значение которых ни разу не было прочитано;
параметры, значение которых ни разу не было прочитано. Функция с именем main и без параметров всегда считается used, даже если никто её не
вызывает.
	написать тесты, подтверждающие работоспособность реализованных API
	Чего НЕ ТРЕБУЕТСЯ делать:
	анализ, действительно ли допустимы выполняемые операции +-*/<>
	анализ, действительно ли возможны преобразования к указанным типам через as
	анализ наличия return во всех ветках функции или invoke on
	компиляцию программы в байт-код / ассемблер / во что-то ещё
	интерпретацию программы